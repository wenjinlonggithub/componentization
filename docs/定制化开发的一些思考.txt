我们面临的核心挑战是：既要支持标准化产品的开发，又要支持针对不同租户的定制化开发，并且要求系统能够快速扩展。在Java和Spring Boot技术栈下，我们可以从代码仓库管理、架构设计、设计模式等多个方面来考虑。
 1. 代码仓库管理
    - 采用多仓库还是单仓库？
      - 标准化产品核心代码放在一个主仓库（core）。
      - 定制化模块可以放在独立的仓库（每个租户一个仓库？或者按功能模块划分？）或者作为主仓库的一个分支（但分支管理在定制化较多时容易混乱，不推荐）。
      - 推荐使用多仓库：核心仓库（core）和多个定制化仓库（customization-tenant1, customization-tenant2, ...）。这样核心代码的更新可以独立发布，定制化仓库通过依赖核心仓库的版本（比如使用Maven或Gradle依赖）来复用核心功能。
      - 或者使用单仓库多模块：在同一个仓库中，核心模块作为基础模块，定制化模块作为独立的模块，通过构建工具来管理依赖。这样便于统一管理，但定制化代码可能会污染主仓库，且不同租户的代码都在同一个仓库，权限管理可能复杂。
 2. 架构设计
    - 插件化架构：将系统划分为核心系统和插件（定制化模块）。核心系统提供基础功能和扩展点，插件通过实现扩展点来提供定制功能。
    - 模块化：使用Spring Boot的自动配置和条件化Bean来加载不同的定制模块。每个定制模块是一个独立的Spring Boot Starter，这样在需要的时候引入依赖即可激活定制逻辑。
 3. 设计模式
    - 策略模式：将算法或业务逻辑抽象为接口，标准实现和定制化实现都实现该接口，通过配置来决定使用哪个实现。
    - 模板方法模式：在核心系统中定义业务逻辑的骨架，将某些步骤定义为抽象方法或钩子（hook），由子类（定制化模块）实现。
    - 观察者模式：核心系统在关键点发布事件，定制化模块可以监听这些事件并执行自己的逻辑。
    - 工厂模式：用于根据条件创建不同的策略实现。
 4. 具体实现方案
    - 定义扩展点（Extension Point）：在核心系统中，将需要定制的地方定义成接口，这些接口就是扩展点。
    - 钩子（Hook）：在业务逻辑的关键节点，调用钩子接口，默认提供空实现，定制化模块可以覆盖这些钩子。
    - 使用Spring的依赖注入和条件注解（如@ConditionalOnProperty, @ConditionalOnClass）来按需加载定制化Bean。
 5. 案例说明
    假设我们有一个订单处理流程，标准流程包括：验证订单、计算价格、保存订单、通知用户。但某些租户希望在保存订单之前进行额外的检查，或者在通知用户时使用短信而不是邮件。
    方案：
      - 定义订单处理器的接口：
        ```java
        public interface OrderProcessor {
            void process(Order order);
        }
        ```
      - 核心系统提供一个默认实现，并在其中定义钩子：
        ```java
        public class DefaultOrderProcessor implements OrderProcessor {
            @Override
            public void process(Order order) {
                validate(order);
                calculatePrice(order);
                // 钩子：保存前扩展点
                beforeSave(order);
                save(order);
                // 钩子：通知前扩展点
                beforeNotify(order);
                notifyUser(order);
            }
            // 钩子方法，空实现，允许定制化覆盖
            protected void beforeSave(Order order) {
                // 默认什么都不做
            }
            protected void beforeNotify(Order order) {
                // 默认什么都不做
            }
            // 其他默认实现方法...
        }
        ```
      - 定制化模块可以继承DefaultOrderProcessor并覆盖钩子方法：
        ```java
        public class CustomOrderProcessor extends DefaultOrderProcessor {
            @Override
            protected void beforeSave(Order order) {
                // 定制逻辑：比如进行额外的检查
                if (order.getAmount() > 10000) {
                    // 需要主管审核
                    audit(order);
                }
            }
            @Override
            protected void beforeNotify(Order order) {
                // 定制通知方式：使用短信
                smsService.send(order.getUser().getPhone(), "您的订单已创建");
                // 阻止默认的邮件通知（可以通过设计来跳过默认通知，或者通过其他方式）
            }
        }
        ```
      - 如何让核心系统使用定制化的处理器？
        我们可以利用Spring的条件配置，当存在定制化的Bean时，使用定制的Bean，否则使用默认的。
        例如，在配置类中：
        ```java
        @Configuration
        public class OrderProcessorConfig {
            @Bean
            @ConditionalOnMissingBean(OrderProcessor.class) // 当容器中没有OrderProcessor时才创建默认的
            public OrderProcessor defaultOrderProcessor() {
                return new DefaultOrderProcessor();
            }
        }
        ```
        在定制化模块中，我们只需要定义CustomOrderProcessor并注入到Spring容器，它就会覆盖默认的Bean。
      - 另一种更灵活的方式：使用事件监听。
        在核心系统中，在关键点发布事件：
        ```java
        public class DefaultOrderProcessor implements OrderProcessor {
            private ApplicationEventPublisher eventPublisher;
            @Override
            public void process(Order order) {
                validate(order);
                calculatePrice(order);
                // 发布保存前事件
                eventPublisher.publishEvent(new BeforeSaveEvent(order));
                save(order);
                eventPublisher.publishEvent(new AfterSaveEvent(order));
                // 通知前事件
                eventPublisher.publishEvent(new BeforeNotifyEvent(order));
                notifyUser(order);
            }
        }
        ```
        定制化模块可以监听这些事件：
        ```java
        @Component
        public class CustomOrderEventListener {
            @EventListener
            public void handleBeforeSave(BeforeSaveEvent event) {
                // 定制逻辑
            }
            @EventListener
            public void handleBeforeNotify(BeforeNotifyEvent event) {
                // 使用短信通知，并阻止默认的邮件通知？
                // 注意：事件监听是同步的，但无法直接阻止默认流程（除非事件对象中有标记可以设置）
                // 如果需要有条件地阻止默认流程，可以在事件对象中设置一个标志，核心流程检查这个标志来决定是否跳过默认操作。
            }
        }
        ```
        事件对象可以设计为：
        ```java
        public class BeforeNotifyEvent extends ApplicationEvent {
            private final Order order;
            private boolean skipDefaultAction = false;
            public BeforeNotifyEvent(Order order) {
                super(order);
                this.order = order;
            }
            public void skipDefaultAction() {
                this.skipDefaultAction = true;
            }
            public boolean isSkipDefaultAction() {
                return skipDefaultAction;
            }
        }
        ```
        然后在核心流程中：
        ```java
        BeforeNotifyEvent event = new BeforeNotifyEvent(order);
        eventPublisher.publishEvent(event);
        if (!event.isSkipDefaultAction()) {
            notifyUser(order);
        }
        ```
 6. 模块化与构建
    - 核心模块：包含所有核心功能，以及定义扩展点（接口）和事件。
    - 定制化模块：作为独立的Maven/Gradle模块，依赖核心模块，并实现扩展点或监听事件。
    - 在构建最终应用时，通过引入不同的定制化模块来实现定制化部署。
 7. 配置管理
    - 使用Spring Profile或自定义属性来激活不同的定制化模块。例如，在application.properties中指定租户ID，然后根据租户ID加载对应的配置和Bean。
 8. 总结
    - 核心系统通过设计扩展点（接口、钩子方法、事件）来提供定制能力。
    - 定制化模块独立开发，通过实现扩展点或监听事件来注入定制逻辑。
    - 利用Spring的依赖注入和条件注解，实现按需加载定制化组件。
    - 代码仓库管理建议：核心代码一个仓库，每个定制化模块一个仓库（或者一个定制化项目一个仓库，里面包含多个模块），通过构建工具管理依赖。
 注意：事件监听的方式解耦更好，但需要注意事件的处理顺序和事务边界。钩子方法更直接，但需要继承，灵活性稍低。在实际项目中，可以根据具体场景选择。
 以上方案可以较好地支持标准化产品的开发，同时为定制化开发提供灵活、快速的扩展能力。

==================================================================================
9. 完整实现案例 - 订单处理系统组件化架构
==================================================================================

本节提供了一个完整的端到端实现案例，展示了如何在实际项目中应用组件化架构。该案例实现了一个支持多租户定制的订单处理系统。

9.1 整体架构设计
-----------------

我们采用多仓库架构，将系统划分为以下几个层次：

```
项目结构:
├── core-system/                 # 核心系统模块
├── customization-tenant1/       # 租户1定制化模块（混合模式：继承+事件）
├── customization-tenant2/       # 租户2定制化模块（纯事件驱动模式）  
├── tenant1-app/                 # 租户1可部署应用
├── tenant2-app/                 # 租户2可部署应用
└── pom.xml                      # 父级POM配置
```

架构图参见：architecture-diagram.txt

9.2 核心系统实现（core-system）
------------------------------

9.2.1 扩展点接口定义
```java
// OrderProcessor.java - 核心扩展点接口
package com.company.core.processor;

public interface OrderProcessor {
    void process(Order order);
}
```

9.2.2 默认处理器实现（含钩子方法和事件发布）
```java
// DefaultOrderProcessor.java - 核心处理器实现
package com.company.core.processor;

@Component
public class DefaultOrderProcessor implements OrderProcessor {

    @Autowired
    private ApplicationEventPublisher eventPublisher;

    @Autowired
    private NotificationService notificationService;

    @Override
    public void process(Order order) {
        // 标准流程
        validate(order);
        calculatePrice(order);
        
        // 事件驱动扩展点
        BeforeSaveEvent beforeSaveEvent = new BeforeSaveEvent(this, order);
        eventPublisher.publishEvent(beforeSaveEvent);
        
        // 钩子方法扩展点
        beforeSave(order);
        
        // 条件执行保存操作
        if (!beforeSaveEvent.isSkipDefaultAction()) {
            save(order);
            eventPublisher.publishEvent(new AfterSaveEvent(this, order));
        }
        
        // 通知前扩展点
        BeforeNotifyEvent beforeNotifyEvent = new BeforeNotifyEvent(this, order);
        eventPublisher.publishEvent(beforeNotifyEvent);
        beforeNotify(order);
        
        // 条件执行通知操作
        if (!beforeNotifyEvent.isSkipDefaultAction()) {
            notifyUser(order);
        }
    }

    // 钩子方法 - 可被子类覆盖
    protected void beforeSave(Order order) {
        // 默认空实现，供定制化模块覆盖
    }

    protected void beforeNotify(Order order) {
        // 默认空实现，供定制化模块覆盖
    }

    // 核心业务方法
    protected void validate(Order order) {
        if (order.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Order amount must be positive");
        }
        System.out.println("Order validated: " + order.getId());
    }

    protected void save(Order order) {
        order.setStatus("SAVED");
        System.out.println("Order saved: " + order.getId());
    }

    protected void notifyUser(Order order) {
        if (order.getUser() != null && order.getUser().getEmail() != null) {
            notificationService.sendEmail(order.getUser().getEmail(), 
                "Your order " + order.getId() + " has been created");
        }
    }
}
```

9.2.3 事件定义（支持条件跳过默认行为）
```java
// BeforeNotifyEvent.java - 通知前事件
package com.company.core.event;

public class BeforeNotifyEvent extends ApplicationEvent {
    private final Order order;
    private boolean skipDefaultAction = false;  // 关键：支持跳过默认行为

    public BeforeNotifyEvent(Object source, Order order) {
        super(source);
        this.order = order;
    }

    public Order getOrder() { return order; }

    public void skipDefaultAction() { this.skipDefaultAction = true; }
    public boolean isSkipDefaultAction() { return skipDefaultAction; }
}
```

9.2.4 条件配置
```java
// CoreSystemConfig.java - 核心系统配置
package com.company.core.config;

@Configuration
public class CoreSystemConfig {

    @Bean
    @ConditionalOnMissingBean(OrderProcessor.class)  // 关键：条件创建
    public OrderProcessor defaultOrderProcessor() {
        return new DefaultOrderProcessor();
    }
}
```

9.3 租户1定制化实现（混合模式：继承+事件）
--------------------------------------

9.3.1 继承模式定制处理器
```java
// CustomOrderProcessor.java - 租户1自定义处理器
package com.company.tenant1.processor;

@Component  // 注意：这个Bean会覆盖默认的OrderProcessor
public class CustomOrderProcessor extends DefaultOrderProcessor {

    @Override
    protected void beforeSave(Order order) {
        // 定制逻辑：高额订单需要审核
        if (order.getAmount().compareTo(new BigDecimal("10000")) > 0) {
            audit(order);
        }
        System.out.println("Tenant1 custom validation completed for order: " + order.getId());
    }

    @Override
    protected void beforeNotify(Order order) {
        // 定制逻辑：使用SMS通知
        if (order.getUser() != null && order.getUser().getPhone() != null) {
            System.out.println("Tenant1 SMS notification: Order " + order.getId() + 
                             " created for " + order.getUser().getPhone());
        }
    }

    private void audit(Order order) {
        System.out.println("AUDIT REQUIRED: High-value order " + order.getId() + 
                         " with amount " + order.getAmount() + " needs manager approval");
        order.setStatus("PENDING_APPROVAL");
    }
}
```

9.3.2 事件监听器（额外业务逻辑）
```java
// OrderEventListener.java - 租户1事件监听器
package com.company.tenant1.listener;

@Component
public class OrderEventListener {

    @EventListener
    public void handleAfterSave(AfterSaveEvent event) {
        System.out.println("Tenant1 Event Listener: Post-save processing for order " + 
                         event.getOrder().getId());
        updateInventory(event.getOrder());  // 库存更新
    }

    @EventListener
    public void handleBeforeNotify(BeforeNotifyEvent event) {
        System.out.println("Tenant1 Event Listener: Custom notification logic for order " + 
                         event.getOrder().getId());
        // 条件跳过默认邮件通知
        if (shouldUseSmsOnly(event.getOrder())) {
            event.skipDefaultAction();  // 关键：跳过默认邮件通知
            System.out.println("Default email notification skipped for tenant1");
        }
    }

    private void updateInventory(Order order) {
        System.out.println("Tenant1: Updating inventory for order " + order.getId());
    }

    private boolean shouldUseSmsOnly(Order order) {
        return order.getUser() != null && order.getUser().getPhone() != null;
    }
}
```

9.3.3 租户配置
```java
// Tenant1Config.java - 租户1配置
package com.company.tenant1.config;

@Configuration
@ConditionalOnProperty(name = "tenant.id", havingValue = "tenant1")
@ComponentScan(basePackages = {"com.company.tenant1", "com.company.core"})
public class Tenant1Config {
    // 当 tenant.id=tenant1 时，自动激活此配置
}
```

9.4 租户2定制化实现（纯事件驱动模式）
----------------------------------

```java
// AdvancedOrderEventListener.java - 租户2高级事件监听器
package com.company.tenant2.listener;

@Component
public class AdvancedOrderEventListener {

    @EventListener
    @Order(1)  // 控制执行顺序
    public void handleBeforeSave(BeforeSaveEvent event) {
        Order order = event.getOrder();
        if (requiresComplexValidation(order)) {
            performComplexValidation(order);  // 复杂验证逻辑
        }
    }

    @EventListener
    public void handleAfterSave(AfterSaveEvent event) {
        Order order = event.getOrder();
        integrateWithExternalSystem(order);  // ERP集成
        generateAdvancedReports(order);      // 高级分析报告
    }

    @EventListener
    public void handleBeforeNotify(BeforeNotifyEvent event) {
        Order order = event.getOrder();
        if (shouldUseAdvancedNotification(order)) {
            sendAdvancedNotification(order);  // 多渠道通知
            event.skipDefaultAction();        // 跳过默认通知
        }
    }

    private void performComplexValidation(Order order) {
        System.out.println("Tenant2: Performing complex validation for order " + order.getId());
        System.out.println("Tenant2: Checking fraud detection systems...");
        System.out.println("Tenant2: Validating customer credit score...");
    }

    private void integrateWithExternalSystem(Order order) {
        System.out.println("Tenant2: Integrating order " + order.getId() + " with ERP system");
        System.out.println("Tenant2: Syncing with warehouse management system");
    }

    private void sendAdvancedNotification(Order order) {
        System.out.println("Tenant2: Sending multi-channel notification for order " + order.getId());
        System.out.println("Tenant2: - Email notification sent");
        System.out.println("Tenant2: - SMS notification sent");  
        System.out.println("Tenant2: - Push notification sent");
        System.out.println("Tenant2: - Dashboard alert created");
    }
}
```

9.5 应用部署配置
--------------

9.5.1 租户1应用配置
```yaml
# tenant1-app/application.yml
tenant:
  id: tenant1                    # 关键：激活租户1配置
  name: "Premium Tenant Application"

spring:
  application:
    name: tenant1-application
  profiles:
    active: tenant1

server:
  port: 8081
```

9.5.2 租户2应用配置  
```yaml
# tenant2-app/application.yml
tenant:
  id: tenant2                    # 关键：激活租户2配置
  name: "Enterprise Tenant Application"

spring:
  application:
    name: tenant2-application
  profiles:
    active: tenant2

server:
  port: 8082

advanced:
  features:
    fraud-detection: true
    erp-integration: true
    advanced-analytics: true
```

9.6 依赖管理配置
--------------

9.6.1 父POM配置
```xml
<!-- pom.xml - 父级配置 -->
<project>
    <groupId>com.company</groupId>
    <artifactId>componentization-parent</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>

    <modules>
        <module>core-system</module>
        <module>customization-tenant1</module>
        <module>customization-tenant2</module>
    </modules>
</project>
```

9.6.2 应用POM配置示例
```xml
<!-- tenant1-app/pom.xml - 租户1应用配置 -->
<project>
    <groupId>com.company</groupId>
    <artifactId>tenant1-app</artifactId>
    <version>1.0.0</version>

    <dependencies>
        <!-- 核心依赖 -->
        <dependency>
            <groupId>com.company</groupId>
            <artifactId>core-system</artifactId>
            <version>1.0.0</version>
        </dependency>
        <!-- 租户1定制化依赖 -->
        <dependency>
            <groupId>com.company</groupId>
            <artifactId>customization-tenant1</artifactId>
            <version>1.0.0</version>
        </dependency>
        <!-- Spring Boot -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
    </dependencies>
</project>
```

9.7 运行效果演示
--------------

9.7.1 租户1运行效果
```
=== TENANT1 APPLICATION DEMO ===

--- Processing Regular Order ---
Order validated: order1
Price calculated for order: order1
Tenant1 Event Listener: Pre-save processing for order order1
Tenant1 custom validation completed for order: order1
Order saved: order1
Tenant1 Event Listener: Post-save processing for order order1
Tenant1: Updating inventory for order order1
Tenant1 Event Listener: Custom notification logic for order order1
Default email notification skipped for tenant1
Tenant1 SMS notification: Order order1 created for 123-456-7890

--- Processing High-Value Order (Audit Required) ---
Order validated: order2
Price calculated for order: order2
Tenant1 Event Listener: Pre-save processing for order order2
AUDIT REQUIRED: High-value order order2 with amount 15000 needs manager approval
Tenant1 custom validation completed for order: order2
Order saved: order2
Tenant1 Event Listener: Post-save processing for order order2
Tenant1: Updating inventory for order order2
```

9.7.2 租户2运行效果
```
=== TENANT2 ENTERPRISE APPLICATION DEMO ===

--- Processing Large Enterprise Order (Complex Validation) ---
Order validated: order2
Price calculated for order: order2
Tenant2: Performing complex validation for order order2
Tenant2: Checking fraud detection systems...
Tenant2: Validating customer credit score...
Order saved: order2
Tenant2: Integrating order order2 with ERP system
Tenant2: Syncing with warehouse management system
Tenant2: Generating advanced analytics report for order order2
Tenant2: Sending multi-channel notification for order order2
Tenant2: - Email notification sent
Tenant2: - SMS notification sent
Tenant2: - Push notification sent
Tenant2: - Dashboard alert created
```

9.8 架构优势总结
--------------

通过这个完整的实现案例，我们可以看到组件化架构的以下优势：

1. **清晰的职责分离**：核心逻辑与定制逻辑完全分离
2. **灵活的扩展方式**：支持继承模式和事件驱动两种扩展方式
3. **条件化配置**：通过配置属性控制模块激活
4. **独立部署**：不同租户可以独立构建和部署
5. **易于维护**：核心系统更新不影响定制化模块
6. **可测试性**：每个模块都可以独立测试

9.9 最佳实践建议
--------------

基于这个实现案例，我们总结出以下最佳实践：

1. **扩展点设计**：
   - 接口定义要稳定，避免频繁变更
   - 提供足够的扩展点，但不要过度设计
   - 钩子方法和事件两种方式可以配合使用

2. **事件设计**：
   - 事件对象要包含足够的上下文信息
   - 支持条件跳过默认行为的能力
   - 注意事件处理的顺序和事务边界

3. **配置管理**：
   - 使用条件注解实现按需加载
   - 通过配置属性控制租户级别的功能开关
   - 保持配置的简洁性和可读性

4. **依赖管理**：
   - 核心模块保持轻量级，避免引入过多依赖
   - 定制化模块只依赖核心模块，避免相互依赖
   - 使用Maven/Gradle管理版本一致性

5. **部署策略**：
   - 每个租户独立的应用配置和部署包
   - 支持多环境部署（开发、测试、生产）
   - 考虑容器化部署和微服务架构

这个完整的实现案例展示了如何将理论设计转化为可运行的代码，为实际项目中的组件化架构实施提供了具体的参考和指导。